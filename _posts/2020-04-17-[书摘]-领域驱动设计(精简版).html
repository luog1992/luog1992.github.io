---
tags: [Y2020, 书摘, 软件设计, DDD]
---

<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html>
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    <meta name="exporter-version" content="Evernote Mac 9.3.2 (459662)" />
    <meta name="created" content="2020-04-17 13:25:54 +0000" />
    <meta name="updated" content="2020-04-17 15:14:06 +0000" />

    <title>领域驱动设计(精简版)-摘要</title>
    <meta name="keywords" content="DDD,领域驱动设计,软件设计" />
    <meta name="description" content="领域驱动设计(精简版) 阅读笔记" />
    <meta name="robots" content="nofollow" />
    <script>{%- include scripts/short_summary.js -%}</script>
  </head>
  <body>
    <div class="blog_summary" id="blog_summary">
      领域驱动设计(Domain-driven Design, DDD)兴起于30年前, 不过照本书所言, 领域驱动设计其实只是<strong>面向对象编程思想</strong>的回归和升华而已.
      为什么说是面向对象编程的回归呢? 因为近些年(2010)来Web的兴起, 大家发现只要将数据从数据库搬到Web上就能创造很大的价值, 也即这个阶段软件设计其实大部分只需要简单的CRUD就够了.
      不过随着业务日趋复杂, 系统日趋庞大复杂, 简单的CRUD显然无法设计出柔性的, 可扩展可维护的系统了, 故这个时候必须要对业务进行进一步的设计/抽象/重构, 而DDD就是一种<strong>指导复杂系统设计的思想</strong>.
      注意, 我个人也认为DDD是一种设计思想, 而非某种技术方案, 不太建议强套DDD中的各种概念来进行系统设计.
      <br><br>
      DDD的核心思想是<strong>创建一个根植于领域, 并精确反映出领域中基本(核心)概念的软件模型</strong>.
      领域, 也即业务领域, 是真实世界中的某些事物, 比如你要设计一个计算广告系统, 就要熟悉计算广告相关的领域知识.
      一般是相关领域的专家对领域知识了解的更多, 这时候就需要软件开发人员和领域专家进行由浅及深的沟通, 逐步挖掘出领域中相关的<strong>核心和非核心概念</strong>, 然后进行<strong>抽象和建模</strong>.
      当完成了模型的设计后, 一般使用面向对象的语言, 如Java, 进行具体的代码实现.
      <br><br>
      这中设计方式是一种<strong>模型驱动</strong>的设计方式, 你抽象的模型最好能够精确反映出领域中的基本概念. 模型驱动设计包含的核心要素有:
      <ul>
        <li><strong>实体: </strong>DDD中最重要的一个概念, 具有唯一标识(如id)的对象, 如: <code>class User(db.Model): ...</code></li>
        <li><strong>值对象: </strong>没有唯一标识, 简单/不可变/可共享的字段集合, 一般包括了实体的某些属性字段, 如<code>user.contact_info</code></li>
        <li><strong>服务: </strong>
          当领域中的某个<strong>过程/转换</strong>不属于某个实体时, 一般单独声明为一个服务, 如 <code>Post.add(...)</code>用于新建一篇帖子,
          不过<code>publish_post(...)</code>不仅要新建帖子, 可能还要进行权限校验/频次控制/发送通知 等其他业务逻辑.
        </li>
        <li><strong>模块: </strong>模块是组织复杂代码的一种方式, 可以提高内聚性, 降低耦合性; 模块之间应当设计一些接口进行互相访问</li>
        <li><strong>聚合: </strong>
          一般而言一个<strong>实体</strong>会包含多个值对象, 也会包含其他对实体的引用, 这种实体一般被称为<strong>聚合根</strong>,
          因为它聚合了其他的一些对象/数据. 外界只可以通过该聚合根来访问其中包含的属性(值对象/其他实体), 故聚合根达到了定义对象所有权和边界的目的.
        </li>
        <li><strong>工厂: </strong>聚合根的创建通常比较复杂, 故一般使用工厂模型来创建聚合根</li>
        <li><strong>资源库: </strong>
          因为DDD设计的重点会在模型上面, 一般不太关心模型的创建/存取, 资源库就是一个全局可访问对象的存储地点.
          注: 工厂一般用于创建复杂的聚合根, 而资源库主要用于获取对象.
          另外我认为资源库这一概念, 如果你用 SQLAlchemy 的话, 我认为 SQLAlchemy 其实扮演的就是资源库的角色,
          而某个具体的 Model 相当于是聚合根, 也即我认为一个 SQLAlchemy 本身兼具了聚合根和资源库的功能(言外之意, 没必要单独实现一个资源库)
        </li>
      </ul>
    </div>
    <div
      id="content"
      style="
        border-color: rgb(241, 241, 241);
        border-width: 1px;
        border-style: solid;
        margin-top: 10px;
        margin-bottom: 10px;
        padding: 10px;
      "
    >
      <h2>概要</h2>
      <ul>
        <li style="margin-top: 10px; margin-bottom: 10px;">
          <div
            style="
              border-color: rgb(255, 255, 212);
              border-width: 2px;
              border-style: solid;
              background-color: #f0f0f0;
              margin-top: 10px;
              margin-bottom: 10px;
            "
          >
            <div style="margin-top: 10px; margin-bottom: 10px;">
              计算机之所以很有用,
              是因为通过使用计算机软件能够解决人们所从事的某个<span
                style="
                  border-bottom-width: 2px;
                  border-bottom-style: solid;
                  border-bottom-color: rgb(0, 0, 255);
                  font-weight: bold;
                  text-decoration: none;
                "
                >领域</span
              >的问题。然而,假如软件的开发人员并没有深入理解软件所处的领域,
              软件就无法很好地解决该领域的问题, 其实用价值就会大打折扣。
            </div>
          </div>
        </li>
        <li style="margin-top: 10px; margin-bottom: 10px;">
          <div
            style="
              border-color: rgb(255, 255, 212);
              border-width: 2px;
              border-style: solid;
              background-color: #f0f0f0;
              margin-top: 10px;
              margin-bottom: 10px;
            "
          >
            <div style="margin-top: 10px; margin-bottom: 10px;">
              布鲁克斯老先生将维护软件的<span
                style="
                  border-bottom-width: 2px;
                  border-bottom-style: solid;
                  border-bottom-color: rgb(0, 0, 255);
                  font-weight: bold;
                  text-decoration: none;
                "
                >“概念完整性”</span
              >作为软件开发的核心问题。软件之所以很复杂、难以维护,
              根本原因就在于软件的概念完整性遭到了破坏,
              甚至开发团队的成员从来就没有意识到有必要去维护软件的概念完整性,
              他们并不是一个真正的团队, 只是一些自行其事的开发人员,
              碰巧在一个团队中一起堆代码而已。
            </div>
          </div>
        </li>
        <li style="margin-top: 10px; margin-bottom: 10px;">
          <div
            style="
              border-color: rgb(255, 255, 212);
              border-width: 2px;
              border-style: solid;
              background-color: #f0f0f0;
              margin-top: 10px;
              margin-bottom: 10px;
            "
          >
            <div style="margin-top: 10px; margin-bottom: 10px;">
              代码的质量如果不加以控制, 就一定会迅速腐烂变质。这是一个客观规律,
              就像在热力学第三定律中,熵总是会增加一样。对于软件开发而言,
              “概念完整性”就相当于热力学第三定律中的熵,
              是衡量软件项目混乱程度的重要指标。DDD
              就是目前维护软件项目“概念完整性”的最佳良药,
              虽然永远不可能出现某种银弹式的技术, 但是 DDD
              能够很好地解决软件开发中的这个核心问题。
            </div>
          </div>
        </li>
        <li style="margin-top: 10px; margin-bottom: 10px;">
          <div
            style="
              border-color: rgb(255, 255, 212);
              border-width: 2px;
              border-style: solid;
              background-color: #f0f0f0;
              margin-top: 10px;
              margin-bottom: 10px;
            "
          >
            <div style="margin-top: 10px; margin-bottom: 10px;">
              曾经有人要我用简练的词汇描述 DDD
              的中心思想,我个人认为这是一个比较难的工作,但我愿意去尝试。我的回答是<span
                style="
                  border-bottom-width: 2px;
                  border-bottom-style: solid;
                  border-bottom-color: rgb(0, 0, 255);
                  font-weight: bold;
                  text-decoration: none;
                "
                >“关注精简的业务模型及实现的匹配”</span
              >。
            </div>
          </div>
          <div>
            如果你了解“模型”的定义是对现实的有选择性的精简, 然后用这样的观点去读
            DDD 这本书, 你就会发现, DDD
            其实没有什么太多的新鲜玩意,它更多地是可以看作是<span
              style="
                border-bottom-width: 2px;
                border-bottom-style: solid;
                border-bottom-color: rgb(0, 0, 255);
                font-weight: bold;
                text-decoration: none;
              "
              >面向对象</span
            >思潮的回归和升华。
          </div>
        </li>
      </ul>

      <h2>第一章 何为领域驱动设计</h2>
      <ul>
        <li style="margin-top: 10px; margin-bottom: 10px;">
          <div
            style="
              border-color: rgb(255, 255, 212);
              border-width: 2px;
              border-style: solid;
              background-color: #f0f0f0;
              margin-top: 10px;
              margin-bottom: 10px;
            "
          >
            <div style="margin-top: 10px; margin-bottom: 10px;">
              软件开发通常被用于将真实世界中已经存在的流程自动化,
              或者为真实的业务问题提供解决方案。需要自动化的业务流程或者真实世界的问题,
              就是软件的领域。从一开始,我们就必须明白软件起源于其领域,
              并且与其领域密切相关。
            </div>
          </div>
          <div>
            为了创建一个好软件,
            你必须知道这个软件究竟是什么。在你充分了解金融业务是什么之前,
            你是做不出一个好的银行业软件系统的, 你必须理解银行业的领域。
          </div>
        </li>
        <li style="margin-top: 10px; margin-bottom: 10px;">
          <div
            style="
              border-color: rgb(255, 255, 212);
              border-width: 2px;
              border-style: solid;
              background-color: #f0f0f0;
              margin-top: 10px;
              margin-bottom: 10px;
            "
          >
            <div style="margin-top: 10px; margin-bottom: 10px;">
              在启动一个软件项目时,我们应该关注软件涉及的领域。软件的最终目的是增进一个特定的领域。为了达到这个目的,
              软件需要跟要它服务的领域和谐相处
            </div>
          </div>
          <div>
            我们怎样才能让软件和领域和谐相处呢?
            <span
              style="
                border-bottom-width: 2px;
                border-bottom-style: solid;
                border-bottom-color: rgb(0, 0, 255);
                font-weight: bold;
                text-decoration: none;
              "
              >最佳方式是让软件成为领域的一个映射</span
            >。软件需要包含领域里重要的核心概念和元素,
            并精确实现它们之间的关系。也就是说,
            <span
              style="
                border-bottom-width: 2px;
                border-bottom-style: solid;
                border-bottom-color: rgb(0, 0, 255);
                font-weight: bold;
                text-decoration: none;
              "
              >软件需要对领域进行建模</span
            >。
          </div>
        </li>
        <li style="margin-top: 10px; margin-bottom: 10px;">
          <div
            style="
              border-color: rgb(255, 255, 212);
              border-width: 2px;
              border-style: solid;
              background-color: #f0f0f0;
              margin-top: 10px;
              margin-bottom: 10px;
            "
          >
            <div style="margin-top: 10px; margin-bottom: 10px;">
              领域是真实世界中某些事物
            </div>
          </div>
          <div>我们需要为该领域创建一个抽象。</div>
          <div>这个抽象是什么? 它是一个模型, 一个关于领域的模型。</div>
          <div>
            模型是我们对目标领域的内部展现方式,它是非常必须的,会贯穿设计和开发的全过程。
          </div>
          <div>
            (特定的领域知识肯定非常庞杂)这对它自身而言也是一个挑战:
            要保留哪些内容放弃哪些内容呢? 这些取舍是设计和软件创建过程的一部分。
          </div>
        </li>
        <li style="margin-top: 10px; margin-bottom: 10px;">
          <div
            style="
              border-color: rgb(255, 255, 212);
              border-width: 2px;
              border-style: solid;
              background-color: #f0f0f0;
              margin-top: 10px;
              margin-bottom: 10px;
            "
          >
            <div style="margin-top: 10px; margin-bottom: 10px;">
              当我们完成了模型的表达(如用文档, UML图等)时,
              我们可以开始做代码的设计(具体的代码实现)。这跟软件设计(整体业务架构)有很大的不同。
            </div>
          </div>
          <div>
            软件设计有不同的方法,其中之一是瀑布设计方法。这种方法包含了一些阶段。
          </div>
          <div>
            另一种方法是敏捷方法学,
            例如极限编程(XP)。这些方法学是不同于瀑布方法的一些活动,
            其产生的原因是很难预先确定所有的需求, 特别是在需求经常变化的情况。
          </div>
          <div>
            敏捷方法借助于实现层面的灵活性,
            通过由业务涉众持续参与的迭代开发和很多重构
          </div>
        </li>
        <li style="margin-top: 10px; margin-bottom: 10px;">
          <div
            style="
              border-color: rgb(225, 206, 239);
              border-width: 2px;
              border-style: solid;
              background-color: #f0f0f0;
              margin-top: 10px;
              margin-bottom: 10px;
            "
          >
            <div style="margin-top: 10px; margin-bottom: 10px;">
              这是设计中很重要的一点。通常,软件架构师或开发人员都会和领域专家之间进行很长时间的讨论。软件专家希望从领域专家那里获取到知识,他们也必须将这些知识转换成有用的形式。
            </div>
          </div>
          <div>
            <img src="/assets/images/20200417/B0FFEEE3-744C-4894-8247-3FC5C15905BE.png"/>
            <img src="/assets/images/20200417/44D5AB74-C1EA-4992-AB1C-8ADB40775F10.png"/>
            <img src="/assets/images/20200417/4C7933C7-E8C1-4245-B8B1-B79D0109174A.png"/>
          </div>
        </li>
      </ul>

      <h2>第二章 通用语言</h2>
      <ul>
        <li style="margin-top: 10px; margin-bottom: 10px;">
          <div
            style="
              border-color: rgb(255, 255, 212);
              border-width: 2px;
              border-style: solid;
              background-color: #f0f0f0;
              margin-top: 10px;
              margin-bottom: 10px;
            "
          >
            <div style="margin-top: 10px; margin-bottom: 10px;">
              <div>
                领域驱动设计的一个核心的原则是使用一种<span
                  style="
                    border-bottom-width: 2px;
                    border-bottom-style: solid;
                    border-bottom-color: rgb(0, 0, 255);
                    font-weight: bold;
                    text-decoration: none;
                  "
                  >基于模型的语言</span
                >。
                因为模型是软件满足领域的共同点,它很适合作为这种通用语言的构造基础。
              </div>
              <div><br /></div>
              <div>
                <span
                  style="
                    border-bottom-width: 2px;
                    border-bottom-style: solid;
                    border-bottom-color: rgb(0, 0, 255);
                    font-weight: bold;
                    text-decoration: none;
                  "
                  >使用模型作为语言的主干</span
                >。要求团队(领域专家+软件专家)在进行所有的交流时都使用一致的语言,
                在代码中也是这样。在共享知识和推敲模型时,
                团队会使用演讲、文字和图形。需要确保团队使用的语言在所有的交流形式中看上去都是一致的。因为这个原因,
                这种语言被称为“通用语言”(Ubiquitous Language)。
              </div>
            </div>
          </div>
        </li>
        <li style="margin-top: 10px; margin-bottom: 10px;">
          <div
            style="
              border-color: rgb(255, 255, 212);
              border-width: 2px;
              border-style: solid;
              background-color: #f0f0f0;
              margin-top: 10px;
              margin-bottom: 10px;
            "
          >
            <div style="margin-top: 10px; margin-bottom: 10px;">
              构建一个类似这样的语言会得到一个清晰的结果:
              <span
                style="
                  border-bottom-width: 2px;
                  border-bottom-style: solid;
                  border-bottom-color: rgb(0, 0, 255);
                  font-weight: bold;
                  text-decoration: none;
                "
                >模型和语言</span
              >相互密切关联。一个对语言的变更会变成对模型的变更。
            </div>
          </div>
        </li>
      </ul>

      <h2>第三章 模型驱动设计</h2>
      <ul>
        <li style="margin-top: 10px; margin-bottom: 10px;">
          <div
            style="
              border-color: rgb(255, 255, 212);
              border-width: 2px;
              border-style: solid;
              background-color: #f0f0f0;
              margin-top: 10px;
              margin-bottom: 10px;
            "
          >
            <div style="margin-top: 10px; margin-bottom: 10px;">
              前面的章节强调过, 以业务领域为中心,
              对于软件开发来说是极为重要的。我们说过, 最重要的是<span
                style="
                  border-bottom-width: 2px;
                  border-bottom-style: solid;
                  border-bottom-color: rgb(0, 0, 255);
                  font-weight: bold;
                  text-decoration: none;
                "
                >创建一个植根于领域、并精确反映出领域中的基本概念的模型</span
              >。
            </div>
          </div>
          <div>
            建模过程的目的是创建一个优良的模型, 下一步是将模型实现成代码。
          </div>
        </li>
        <li style="margin-top: 10px; margin-bottom: 10px;">
          <div
            style="
              border-color: rgb(255, 255, 212);
              border-width: 2px;
              border-style: solid;
              background-color: #f0f0f0;
              margin-top: 10px;
              margin-bottom: 10px;
            "
          >
            <div style="margin-top: 10px; margin-bottom: 10px;">
              选择一个能够被轻易和准确地转换成代码的模型是很重要的。根本的问题是:
              我们应该如何完成从模型到代码的转换。
            </div>
          </div>
          <div>
            一个推荐的设计技术是创建分析模型,
            它被认为是与代码设计相互分离的、通常是由不同的人完成的。
            分析模型是业务领域分析的结果, 此模型不需要考虑软件如何实现。
          </div>
          <div>
            如果分析人员独立工作,
            他们最终也会创建出一个模型。当这个模型被传递给开发人员,
            分析人员的一些关于领域和模型的知识丢失了。
          </div>
          <div>
            一种更好的方法是将领域建模和设计紧密关联起来。
            模型在构建时就考虑到软件实现和设计。开发人员应该被加入到建模的过程中来。
          </div>
          <div>
            (通常选择OO语言进行编程实现)面向对象编程非常来实现模型,
            因为它们基于同一个范型(即,面向对象)。面向对象编程提供了对象的类、类之间的关联关系、对象实例、以及对象实例之间的消息通信。
            面向对象编程语言使得在带有关联关系的模型对象与它们的编程对等物之间创建直接的映射成为了可能。
          </div>
        </li>
        <li style="margin-top: 10px; margin-bottom: 10px;">
          <div style="font-size: 18px; margin-top: 10px; margin-bottom: 10px;">
            <a
              href="marginnote3app://note/AAB79A15-7338-469E-9531-4355876FD9AC"
              style="font-size: 18px;"
              >模型驱动设计要素</a
            >
          </div>
          <div
            style="
              border-color: rgb(255, 255, 212);
              border-width: 2px;
              border-style: solid;
              background-color: #f0f0f0;
              margin-top: 10px;
              margin-bottom: 10px;
            "
          >
            <img
              src="/assets/images/20200417/A6447E69-7FB3-4879-8820-E0F7CBC7C8AA.png"
              width="1120"
            />
          </div>
        </li>
        <li style="margin-top: 10px; margin-bottom: 10px;">
          <div style="font-size: 18px; margin-top: 10px; margin-bottom: 10px;">
            <a
              href="marginnote3app://note/8B1542C4-993C-4CFF-B596-01634153B93D"
              style="font-size: 18px;"
              >分层架构</a
            >
          </div>
          <div
            style="
              border-color: rgb(255, 255, 212);
              border-width: 2px;
              border-style: solid;
              background-color: #f0f0f0;
              margin-top: 10px;
              margin-bottom: 10px;
            "
          >
            <img
              src="/assets/images/20200417/754FA031-7CB8-4AF4-8082-A446DCD30F00.png"
              width="1120"
            />
          </div>
          <div>
            <img
              src="/assets/images/20200417/D0C7DC88-539C-4176-A8D6-3CA68B19FEDB.png"
              width="1120"
            />
          </div>
          <div>
            因此,将一个复杂的程序划分成多个层。为每一个层开发一个<span
              style="
                border-bottom-width: 2px;
                border-bottom-style: solid;
                border-bottom-color: rgb(0, 0, 255);
                font-weight: bold;
                text-decoration: none;
              "
              >内聚</span
            >的设计, 让每个层仅<span
              style="
                border-bottom-width: 2px;
                border-bottom-style: solid;
                border-bottom-color: rgb(0, 0, 255);
                font-weight: bold;
                text-decoration: none;
              "
              >依赖</span
            >于它底下的那些层。遵照标准的架构模式实现与其上面的那些层的<span
              style="
                border-bottom-width: 2px;
                border-bottom-style: solid;
                border-bottom-color: rgb(0, 0, 255);
                font-weight: bold;
                text-decoration: none;
              "
              >低耦合</span
            >。将领域模型相关的代码集中到一个层中,
            把它从用户界面、应用和基础设施代码中隔离开来。<span
              style="
                border-bottom-width: 2px;
                border-bottom-style: solid;
                border-bottom-color: rgb(0, 0, 255);
                font-weight: bold;
                text-decoration: none;
              "
              >领域对象不必再承担显示自己、保存自己、管理应用任务的职责,
              而是专注于表达领域模型</span
            >。 这会让一个模型逐渐进化得足够丰满、 足够清晰,
            以便捕获基本的业务知识, 并且能够正常工作。
          </div>
        </li>
        <li style="margin-top: 10px; margin-bottom: 10px;">
          <div
            style="
              border-color: rgb(214, 232, 255);
              border-width: 2px;
              border-style: solid;
              background-color: #f0f0f0;
              margin-top: 10px;
              margin-bottom: 10px;
            "
          >
            <div style="margin-top: 10px; margin-bottom: 10px;">实体</div>
          </div>
        </li>
        <ul>
          <li style="margin-top: 10px; margin-bottom: 10px;">
            <div
              style="
                border-color: rgb(255, 255, 212);
                border-width: 2px;
                border-style: solid;
                background-color: #f0f0f0;
                margin-top: 10px;
                margin-bottom: 10px;
              "
            >
              <div style="margin-top: 10px; margin-bottom: 10px;">
                有一类对象看上去好像拥有<span
                  style="
                    border-bottom-width: 2px;
                    border-bottom-style: solid;
                    border-bottom-color: rgb(0, 0, 255);
                    font-weight: bold;
                    text-decoration: none;
                  "
                  >标识符</span
                >,
                它的标识符在历经软件的各种状态变更后仍能保持一致。对这些对象而言,
                重要的不是其属性, 而是其延续性和标识,
                对象的延续性和标识会跨越甚至能够超出软件系统的生命周期。我们把这样的对象称为实体。
              </div>
            </div>
          </li>
          <li style="margin-top: 10px; margin-bottom: 10px;">
            <div
              style="
                border-color: rgb(255, 255, 212);
                border-width: 2px;
                border-style: solid;
                background-color: #f0f0f0;
                margin-top: 10px;
                margin-bottom: 10px;
              "
            >
              <div style="margin-top: 10px; margin-bottom: 10px;">
                因此,在软件中实现实体意味着创建标识符。对一个人而言,其标识符可能是属性的组合:
                名称、出生日期、出生地、父母姓名、当前地址。在美国,
                社会保险编号也会被用来创建标识符。对一个银行账户来说,
                账户编号看上去已经足以作为标识符了。
              </div>
            </div>
          </li>
        </ul>
        <li style="margin-top: 10px; margin-bottom: 10px;">
          <div
            style="
              border-color: rgb(214, 232, 255);
              border-width: 2px;
              border-style: solid;
              background-color: #f0f0f0;
              margin-top: 10px;
              margin-bottom: 10px;
            "
          >
            <div style="margin-top: 10px; margin-bottom: 10px;">值对象</div>
          </div>
        </li>
        <ul>
          <li style="margin-top: 10px; margin-bottom: 10px;">
            <div
              style="
                border-color: rgb(255, 255, 212);
                border-width: 2px;
                border-style: solid;
                background-color: #f0f0f0;
                margin-top: 10px;
                margin-bottom: 10px;
              "
            >
              <div style="margin-top: 10px; margin-bottom: 10px;">
                有的时候我们需要包含一个<span
                  style="
                    border-bottom-width: 2px;
                    border-bottom-style: solid;
                    border-bottom-color: rgb(0, 0, 255);
                    font-weight: bold;
                    text-decoration: none;
                  "
                  >领域对象的某些属性</span
                >。 我们对它是哪一个对象并不感兴趣,
                而是只关心它所拥有的属性。用来描述领域的特定方面、并且没有标识符的一个对象,
                叫做值对象。
              </div>
            </div>
            <div>
              e.g.
              让我们考虑一个绘画应用。用户会看到一个画布且他能够用任何宽度、样式和颜色来画任何点和线。创建一个叫做
              Point 的类非常有用,程序会对画布上的每一个点创建这个类的一个实例。
            </div>
          </li>
          <li style="margin-top: 10px; margin-bottom: 10px;">
            <div
              style="
                border-color: rgb(255, 255, 212);
                border-width: 2px;
                border-style: solid;
                background-color: #f0f0f0;
                margin-top: 10px;
                margin-bottom: 10px;
              "
            >
              <div style="margin-top: 10px; margin-bottom: 10px;">
                实际上,只建议选择那些符合实体定义的对象作为实体,
                而将剩下的对象实现为值对象
              </div>
            </div>
          </li>
          <li style="margin-top: 10px; margin-bottom: 10px;">
            <div
              style="
                border-color: rgb(255, 255, 212);
                border-width: 2px;
                border-style: solid;
                background-color: #f0f0f0;
                margin-top: 10px;
                margin-bottom: 10px;
              "
            >
              <div style="margin-top: 10px; margin-bottom: 10px;">
                <span
                  style="
                    border-bottom-width: 2px;
                    border-bottom-style: solid;
                    border-bottom-color: rgb(0, 0, 255);
                    font-weight: bold;
                    text-decoration: none;
                  "
                  >没有标识符</span
                >, 值对象就可以被轻易地创建或者丢弃。
              </div>
            </div>
          </li>
          <li style="margin-top: 10px; margin-bottom: 10px;">
            <div
              style="
                border-color: rgb(255, 255, 212);
                border-width: 2px;
                border-style: solid;
                background-color: #f0f0f0;
                margin-top: 10px;
                margin-bottom: 10px;
              "
            >
              <div style="margin-top: 10px; margin-bottom: 10px;">
                实现为<span
                  style="
                    border-bottom-width: 2px;
                    border-bottom-style: solid;
                    border-bottom-color: rgb(0, 0, 255);
                    font-weight: bold;
                    text-decoration: none;
                  "
                  >不可变</span
                >的, 并且不具有标识符, 值对象就能够被共享了。
              </div>
            </div>
          </li>
          <li style="margin-top: 10px; margin-bottom: 10px;">
            <div
              style="
                border-color: rgb(255, 255, 212);
                border-width: 2px;
                border-style: solid;
                background-color: #f0f0f0;
                margin-top: 10px;
                margin-bottom: 10px;
              "
            >
              <div style="margin-top: 10px; margin-bottom: 10px;">
                值对象应该保持很小、很简单。当其他参与方需要一个值对象时,可以简单地传递值,或者创建一个副本。
              </div>
            </div>
          </li>
          <li style="margin-top: 10px; margin-bottom: 10px;">
            <div
              style="
                border-color: rgb(225, 206, 239);
                border-width: 2px;
                border-style: solid;
                background-color: #f0f0f0;
                margin-top: 10px;
                margin-bottom: 10px;
              "
            >
              <img
                src="/assets/images/20200417/0CC06B2F-E12C-4848-9E00-A9FACAAA8DCD.png"
                width="1120"
              />
            </div>
          </li>
        </ul>
        <li style="margin-top: 10px; margin-bottom: 10px;">
          <div
            style="
              border-color: rgb(214, 232, 255);
              border-width: 2px;
              border-style: solid;
              background-color: #f0f0f0;
              margin-top: 10px;
              margin-bottom: 10px;
            "
          >
            <div style="margin-top: 10px; margin-bottom: 10px;">服务</div>
          </div>
        </li>
        <ul>
          <li style="margin-top: 10px; margin-bottom: 10px;">
            <div
              style="
                border-color: rgb(255, 255, 212);
                border-width: 2px;
                border-style: solid;
                background-color: #f0f0f0;
                margin-top: 10px;
                margin-bottom: 10px;
              "
            >
              <div style="margin-top: 10px; margin-bottom: 10px;">
                领域中的关键概念被引入到语言中,语言中的名词很容易被映射成对象。语言中对应那些名词的动词成为了那些对象的行为。但是有些领域中的动作,
                它们是一些动词,
                看上去却不属于任何对象。它们代表了领域中的一个重要的行为,
                所以不能忽略它们或者简单地把它们合并到某个实体或者值对象中
              </div>
            </div>
            <div>
              例如, 为了从一个账户向另一个账户转钱,
              这个功能应该放到转出的账户还是在接收的账户中?
            </div>
          </li>
          <li style="margin-top: 10px; margin-bottom: 10px;">
            <div
              style="
                border-color: rgb(255, 255, 212);
                border-width: 2px;
                border-style: solid;
                background-color: #f0f0f0;
                margin-top: 10px;
                margin-bottom: 10px;
              "
            >
              <div style="margin-top: 10px; margin-bottom: 10px;">
                当领域中的一个重要的过程或者转换不属于一个实体或者值对象的职责时,
                向模型中添加一个操作, 作为一个单独的接口将其声明为一个服务。
              </div>
            </div>
          </li>
          <li style="margin-top: 10px; margin-bottom: 10px;">
            <div
              style="
                border-color: rgb(255, 255, 212);
                border-width: 2px;
                border-style: solid;
                background-color: #f0f0f0;
                margin-top: 10px;
                margin-bottom: 10px;
              "
            >
              <div style="margin-top: 10px; margin-bottom: 10px;">
                <div>服务的特征:</div>
                <div><br /></div>
                <div>
                  1. 服务执行的操作代表了一个领域概念,
                  这个领域概念无法自然地隶属于一个实体或者值对象。
                </div>
                <div>
                  2. 被执行的操作涉及到领域中的其他多个的对象(实体/值对象…)
                </div>
                <div>3. 操作是无状态的(服务本质上是一个过程)</div>
              </div>
            </div>
          </li>
          <li style="margin-top: 10px; margin-bottom: 10px;">
            <div
              style="
                border-color: rgb(225, 206, 239);
                border-width: 2px;
                border-style: solid;
                background-color: #f0f0f0;
                margin-top: 10px;
                margin-bottom: 10px;
              "
            >
              <div style="margin-top: 10px; margin-bottom: 10px;">
                <div>
                  让我们考虑一个实际的 Web
                  报表应用的例子。报表使用存储在数据库中的数据,
                  它们会基于模版来生成。最终的结果是一个在 Web
                  浏览器中可以显示给用户查看的HTML 页面。
                </div>
                <div><br /></div>
                <div>用户 查询数据库 选择 报表类型</div>
                <div>
                  App 根据 报表类型 调用 领域模型中的报表生成<span
                    style="
                      border-bottom-width: 2px;
                      border-bottom-style: solid;
                      border-bottom-color: rgb(0, 0, 255);
                      font-weight: bold;
                      text-decoration: none;
                    "
                    >服务</span
                  >
                </div>
              </div>
            </div>
          </li>
        </ul>
        <li style="margin-top: 10px; margin-bottom: 10px;">
          <div
            style="
              border-color: rgb(214, 232, 255);
              border-width: 2px;
              border-style: solid;
              background-color: #f0f0f0;
              margin-top: 10px;
              margin-bottom: 10px;
            "
          >
            <div style="margin-top: 10px; margin-bottom: 10px;">模块</div>
          </div>
        </li>
        <ul>
          <li style="margin-top: 10px; margin-bottom: 10px;">
            <div
              style="
                border-color: rgb(255, 255, 212);
                border-width: 2px;
                border-style: solid;
                background-color: #f0f0f0;
                margin-top: 10px;
                margin-bottom: 10px;
              "
            >
              <div style="margin-top: 10px; margin-bottom: 10px;">
                基于这个原因(项目日趋复杂, 庞大), 必须将模型组织到模块中。
                模块被用来作为组织相关概念和任务以便降低复杂性的一种方法。
              </div>
            </div>
          </li>
          <li style="margin-top: 10px; margin-bottom: 10px;">
            <div
              style="
                border-color: rgb(255, 255, 212);
                border-width: 2px;
                border-style: solid;
                background-color: #f0f0f0;
                margin-top: 10px;
                margin-bottom: 10px;
              "
            >
              <div style="margin-top: 10px; margin-bottom: 10px;">
                另一个使用模块的原因跟代码质量有关。
                普遍认为软件代码应该具有高层次的内聚性和低层次的耦合度。虽然内聚开始于类和方法级别,它也可以应用于模块级别。
              </div>
            </div>
          </li>
          <li style="margin-top: 10px; margin-bottom: 10px;">
            <div
              style="
                border-color: rgb(255, 255, 212);
                border-width: 2px;
                border-style: solid;
                background-color: #f0f0f0;
                margin-top: 10px;
                margin-bottom: 10px;
              "
            >
              <div style="margin-top: 10px; margin-bottom: 10px;">
                模块应该具有定义好的接口,
                这些接口可以被其他的模块访问。最好用访问一个接口的方式,
                而不是调用模块中的三个对象, 因为这样做可以降低耦合度。
              </div>
            </div>
          </li>
        </ul>
        <li style="margin-top: 10px; margin-bottom: 10px;">
          <div
            style="
              border-color: rgb(214, 232, 255);
              border-width: 2px;
              border-style: solid;
              background-color: #f0f0f0;
              margin-top: 10px;
              margin-bottom: 10px;
            "
          >
            <div style="margin-top: 10px; margin-bottom: 10px;">聚合</div>
          </div>
        </li>
        <ul>
          <li style="margin-top: 10px; margin-bottom: 10px;">
            <div
              style="
                border-color: rgb(255, 255, 212);
                border-width: 2px;
                border-style: solid;
                background-color: #f0f0f0;
                margin-top: 10px;
                margin-bottom: 10px;
              "
            >
              <div style="margin-top: 10px; margin-bottom: 10px;">
                聚合是一个用来定义对象所有权和边界的领域模式。
              </div>
            </div>
          </li>
          <li style="margin-top: 10px; margin-bottom: 10px;">
            <div
              style="
                border-color: rgb(255, 255, 212);
                border-width: 2px;
                border-style: solid;
                background-color: #f0f0f0;
                margin-top: 10px;
                margin-bottom: 10px;
              "
            >
              <div style="margin-top: 10px; margin-bottom: 10px;">
                一个模型会包含众多的领域对象。无论在设计时做了多少考虑,
                我们都会看到很多对象会跟其他的对象发生关联,
                形成了一个复杂的关系网。
              </div>
            </div>
            <div>
              在模型中拥有复杂关联的对象发生变化时, 很难保证其一致性。
            </div>
          </li>
          <li style="margin-top: 10px; margin-bottom: 10px;">
            <div
              style="
                border-color: rgb(255, 255, 212);
                border-width: 2px;
                border-style: solid;
                background-color: #f0f0f0;
                margin-top: 10px;
                margin-bottom: 10px;
              "
            >
              <div style="margin-top: 10px; margin-bottom: 10px;">
                因此, 使用聚合。聚合是针对<span
                  style="
                    border-bottom-width: 2px;
                    border-bottom-style: solid;
                    border-bottom-color: rgb(0, 0, 255);
                    font-weight: bold;
                    text-decoration: none;
                  "
                  >数据变化</span
                >可以考虑成<span
                  style="
                    border-bottom-width: 2px;
                    border-bottom-style: solid;
                    border-bottom-color: rgb(0, 0, 255);
                    font-weight: bold;
                    text-decoration: none;
                  "
                  >一个单元(整体)</span
                >的一组关联的对象。聚合使用<span
                  style="
                    border-bottom-width: 2px;
                    border-bottom-style: solid;
                    border-bottom-color: rgb(0, 0, 255);
                    font-weight: bold;
                    text-decoration: none;
                  "
                  >边界</span
                >将内部和外部的对象划分开来。每个聚合都有一个<span
                  style="
                    border-bottom-width: 2px;
                    border-bottom-style: solid;
                    border-bottom-color: rgb(0, 0, 255);
                    font-weight: bold;
                    text-decoration: none;
                  "
                  >根</span
                >。这个根是一个实体,
                并且它是外部可以访问的唯一的对象。根对象可以持有对任意聚合对象的引用,
                其他的对象可以互相持有彼此的引用,
                <span
                  style="
                    border-bottom-width: 2px;
                    border-bottom-style: solid;
                    border-bottom-color: rgb(0, 0, 255);
                    font-weight: bold;
                    text-decoration: none;
                  "
                  >但一个外部对象只能持有对根对象的引用</span
                >。如果边界内还有其他的实体, 那些实体的标识符是本地化的,
                只在聚合内有意义。
              </div>
            </div>
          </li>
          <li style="margin-top: 10px; margin-bottom: 10px;">
            <div
              style="
                border-color: rgb(255, 255, 212);
                border-width: 2px;
                border-style: solid;
                background-color: #f0f0f0;
                margin-top: 10px;
                margin-bottom: 10px;
              "
            >
              <div style="margin-top: 10px; margin-bottom: 10px;">
                将<span
                  style="
                    border-bottom-width: 2px;
                    border-bottom-style: solid;
                    border-bottom-color: rgb(0, 0, 255);
                    font-weight: bold;
                    text-decoration: none;
                  "
                  >实体和值对象</span
                >聚集在<span
                  style="
                    border-bottom-width: 2px;
                    border-bottom-style: solid;
                    border-bottom-color: rgb(0, 0, 255);
                    font-weight: bold;
                    text-decoration: none;
                  "
                  >聚合</span
                >之中, 并且定义各个聚合之间的<span
                  style="
                    border-bottom-width: 2px;
                    border-bottom-style: solid;
                    border-bottom-color: rgb(0, 0, 255);
                    font-weight: bold;
                    text-decoration: none;
                  "
                  >边界</span
                >。为每个聚合选择一个实体作为<span
                  style="
                    border-bottom-width: 2px;
                    border-bottom-style: solid;
                    border-bottom-color: rgb(0, 0, 255);
                    font-weight: bold;
                    text-decoration: none;
                  "
                  >根</span
                >, 并且<span
                  style="
                    border-bottom-width: 2px;
                    border-bottom-style: solid;
                    border-bottom-color: rgb(0, 0, 255);
                    font-weight: bold;
                    text-decoration: none;
                  "
                  >通过根来控制所有对边界内的对象的访问</span
                >。允许外部对象仅持有对根的引用。对内部成员的临时引用可以被传递出来,
                但是仅能用于单个操作之中。因为由根对象来进行<span
                  style="
                    border-bottom-width: 2px;
                    border-bottom-style: solid;
                    border-bottom-color: rgb(0, 0, 255);
                    font-weight: bold;
                    text-decoration: none;
                  "
                  >访问控制</span
                >,
                将无法盲目地对内部对象进行变更。这种安排使得强化聚合内对象的不变量变得可行,
                并且对聚合而言, 它在任何<span
                  style="
                    border-bottom-width: 2px;
                    border-bottom-style: solid;
                    border-bottom-color: rgb(0, 0, 255);
                    font-weight: bold;
                    text-decoration: none;
                  "
                  >状态变更</span
                >中都是作为一个<span
                  style="
                    border-bottom-width: 2px;
                    border-bottom-style: solid;
                    border-bottom-color: rgb(0, 0, 255);
                    font-weight: bold;
                    text-decoration: none;
                  "
                  >整体</span
                >。
              </div>
            </div>
          </li>
          <li style="margin-top: 10px; margin-bottom: 10px;">
            <div
              style="
                border-color: rgb(225, 206, 239);
                border-width: 2px;
                border-style: solid;
                background-color: #f0f0f0;
                margin-top: 10px;
                margin-bottom: 10px;
              "
            >
              <img
                src="/assets/images/20200417/D69A6F71-CABF-478E-9C02-BA7A30201583.png"
                width="1120"
              />
            </div>
            <div>
              聚合的一个简单的例子如上图所示。客户(Customer)是聚合的根,并且其他所有的对象都是内部的。如果需要地址(Address),
              一个它的副本将被传递给外部对象。
            </div>
          </li>
        </ul>
        <li style="margin-top: 10px; margin-bottom: 10px;">
          <div
            style="
              border-color: rgb(214, 232, 255);
              border-width: 2px;
              border-style: solid;
              background-color: #f0f0f0;
              margin-top: 10px;
              margin-bottom: 10px;
            "
          >
            <div style="margin-top: 10px; margin-bottom: 10px;">工厂</div>
          </div>
        </li>
        <ul>
          <li style="margin-top: 10px; margin-bottom: 10px;">
            <div
              style="
                border-color: rgb(255, 255, 212);
                border-width: 2px;
                border-style: solid;
                background-color: #f0f0f0;
                margin-top: 10px;
                margin-bottom: 10px;
              "
            >
              <div style="margin-top: 10px; margin-bottom: 10px;">
                实体和聚合常常会很大很复杂,过于复杂以至于难以通过根实体的构造器来创建。
              </div>
            </div>
          </li>
          <li style="margin-top: 10px; margin-bottom: 10px;">
            <div
              style="
                border-color: rgb(255, 255, 212);
                border-width: 2px;
                border-style: solid;
                background-color: #f0f0f0;
                margin-top: 10px;
                margin-bottom: 10px;
              "
            >
              <div style="margin-top: 10px; margin-bottom: 10px;">
                工厂被用来封装对象创建所必需的知识,它们对创建聚合特别有用。
                当聚合的根被创建后, 所有聚合包含的对象将随之创建,
                所有的不变量得到了强化。
              </div>
            </div>
          </li>
          <li style="margin-top: 10px; margin-bottom: 10px;">
            <div
              style="
                border-color: rgb(255, 255, 212);
                border-width: 2px;
                border-style: solid;
                background-color: #f0f0f0;
                margin-top: 10px;
                margin-bottom: 10px;
              "
            >
              <div style="margin-top: 10px; margin-bottom: 10px;">
                <div>
                  有时工厂是不需要的, 一个简单的构造器就足够了。
                  在如下情况下应该使用构造器:
                </div>
                <div><br /></div>
                <div> 构造过程并不复杂。</div>
                <div>
                   一个对象的创建不涉及到其他对象的创建,
                  可以将所有需要的属性传递给构造器。
                </div>
                <div>
                   客户对实现很感兴趣, 可能希望选择使用策略(Strategy)模式。
                </div>
                <div>
                   类是特定的类型, 不存在到层级,
                  所以不用在一系列的具体实现中进行选择。
                </div>
              </div>
            </div>
          </li>
          <li style="margin-top: 10px; margin-bottom: 10px;">
            <div
              style="
                border-color: rgb(225, 206, 239);
                border-width: 2px;
                border-style: solid;
                background-color: #f0f0f0;
                margin-top: 10px;
                margin-bottom: 10px;
              "
            >
              <img
                src="/assets/images/20200417/D3D584FD-F793-45ED-A7B1-E50B7175C485.png"
                width="1120"
              />
            </div>
            <div>
              上图中通过工厂 RouteFactory 创建了一个聚合根 Route,
              在创建的过程中, 会把聚合根所需的值对象 City 也创建好
            </div>
          </li>
        </ul>
        <li style="margin-top: 10px; margin-bottom: 10px;">
          <div
            style="
              border-color: rgb(214, 232, 255);
              border-width: 2px;
              border-style: solid;
              background-color: #f0f0f0;
              margin-top: 10px;
              margin-bottom: 10px;
            "
          >
            <div style="margin-top: 10px; margin-bottom: 10px;">资源库</div>
          </div>
        </li>
        <ul>
          <li style="margin-top: 10px; margin-bottom: 10px;">
            <div
              style="
                border-color: rgb(255, 255, 212);
                border-width: 2px;
                border-style: solid;
                background-color: #f0f0f0;
                margin-top: 10px;
                margin-bottom: 10px;
              "
            >
              <div style="margin-top: 10px; margin-bottom: 10px;">
                在一种面向对象的语言中,我们必须保持对一个对象的引用以便能够使用它。<span
                  style="
                    border-bottom-width: 2px;
                    border-bottom-style: solid;
                    border-bottom-color: rgb(0, 0, 255);
                    font-weight: bold;
                    text-decoration: none;
                  "
                  >为了获得这样的引用,
                  客户必须创建一个对象或者通过导航已有的关联关系从另一个对象中获得它</span
                >。例如, 为了从一个聚合中获得一个值对象,
                客户程序需要向聚合的根发送请求。
              </div>
            </div>
          </li>
          <li style="margin-top: 10px; margin-bottom: 10px;">
            <div
              style="
                border-color: rgb(255, 255, 212);
                border-width: 2px;
                border-style: solid;
                background-color: #f0f0f0;
                margin-top: 10px;
                margin-bottom: 10px;
              "
            >
              <div style="margin-top: 10px; margin-bottom: 10px;">
                要使用一个对象, 则意味着这个对象已经被创建完毕了。
                如果这个对象是聚合的根, 那么它是一个实体,
                它会被保存为一个持久化的状态, 可能是在数据库中,
                也可能是其他的持久化形式。如果它是一个值对象,
                可以通过导航一个关联关系从一个实体中获得它。实际上大量的对象都可以从数据库中直接获取到。
              </div>
            </div>
          </li>
          <li style="margin-top: 10px; margin-bottom: 10px;">
            <div
              style="
                border-color: rgb(255, 255, 212);
                border-width: 2px;
                border-style: solid;
                background-color: #f0f0f0;
                margin-top: 10px;
                margin-bottom: 10px;
              "
            >
              <div style="margin-top: 10px; margin-bottom: 10px;">
                客户程序需要有一个实用的手段来<span
                  style="
                    border-bottom-width: 2px;
                    border-bottom-style: solid;
                    border-bottom-color: rgb(0, 0, 255);
                    font-weight: bold;
                    text-decoration: none;
                  "
                  >获取已存在领域对象的引用</span
                >。
              </div>
            </div>
            <div>
              因此, 使用一个资源库, 它的目的是<span
                style="
                  border-bottom-width: 2px;
                  border-bottom-style: solid;
                  border-bottom-color: rgb(0, 0, 255);
                  font-weight: bold;
                  text-decoration: none;
                "
                >封装所有获取对象引用所需的逻辑</span
              >。
            </div>
            <div>
              资源库会保存对某些对象的引用。当一个对象被创建之后,
              它可以被保存到资源库中,
              可以从资源库中获取到以备后续使用。如果客户程序从资源库中请求一个对象,
              而资源库中不存在, 就会从存储介质中获取它。不管怎样,
              <span
                style="
                  border-bottom-width: 2px;
                  border-bottom-style: solid;
                  border-bottom-color: rgb(0, 0, 255);
                  font-weight: bold;
                  text-decoration: none;
                "
                >资源库扮演了一个全局可访问对象的存储地点</span
              >。
            </div>
            <div>
              <span
                style="
                  border-bottom-width: 2px;
                  border-bottom-style: solid;
                  border-bottom-color: rgb(0, 0, 255);
                  font-weight: bold;
                  text-decoration: none;
                "
                >总体的结果是领域模型本身与需要保存对象或它们的引用、访问底层持久化基础设施实现了解耦。</span
              >
            </div>
          </li>
          <li style="margin-top: 10px; margin-bottom: 10px;">
            <div
              style="
                border-color: rgb(225, 206, 239);
                border-width: 2px;
                border-style: solid;
                background-color: #f0f0f0;
                margin-top: 10px;
                margin-bottom: 10px;
              "
            >
              <img
                src="/assets/images/20200417/71706D58-A174-4302-949D-0CD3CEABF4D5.png"
                width="1120"
              />
            </div>
            <div>
              以 SQLAlchemy 为例, 假设有一个 SQLAlchemy 模型 User,
              我觉得就可以把 SQLAlchemy 看做是 Repository, 而底层的 DB
              则用于持久化储存. 因为 SQLAlchemy 本身就承担了基本的 CURD 功能.
            </div>
            <div>
              <img
                src="/assets/images/20200417/99FA8CF0-4BF8-44C5-82DF-D4F100DB94AF.png"
                width="1120"
              />
            </div>
          </li>
          <li style="margin-top: 10px; margin-bottom: 10px;">
            <div
              style="
                border-color: rgb(255, 255, 212);
                border-width: 2px;
                border-style: solid;
                background-color: #f0f0f0;
                margin-top: 10px;
                margin-bottom: 10px;
              "
            >
              <div style="margin-top: 10px; margin-bottom: 10px;">
                工厂和资源库之间存在一定的关系。它们都是模型驱动设计中的模式,
                它们都能帮助我们管理领域对象的生命周期。然而工厂关注的是对象的创建,
                而资源库关注的是已经存在的对象。
              </div>
            </div>
            <div>
              当一个新对象被添加到资源库时,
              它应该是先由工厂创建好的,然后它应该被传递给资源库,由资源库来保存它,见下面的例子:
            </div>
            <div>
              <img
                src="/assets/images/20200417/FA6EA618-4BA4-4C01-B117-66F0E0C08A83.png"
                width="1120"
              />
            </div>
            <div>
              还是以 SQLAlchemy 模型 User 为例: class User(db.Model): id =
              Column(…) name = Column(…) def add(cls, name): user =
              cls(name=name) db.session.add(user) db.session.commit() return
              user 则 User 可以认为是一个聚合根, User.get
              就是创建实例的一个工厂方法(创建过程比较简单,
              没有使用单独的工厂方法),
              创建完以后将实例user交给db(SQLAlchemy)进行保存.
            </div>
          </li>
        </ul>
      </ul>

      <h2>第四章 面向深层理解的重构</h2>
      <ul>
        <li style="margin-top: 10px; margin-bottom: 10px;">
          <div
            style="
              border-color: rgb(214, 232, 255);
              border-width: 2px;
              border-style: solid;
              background-color: #f0f0f0;
              margin-top: 10px;
              margin-bottom: 10px;
            "
          >
            <div style="margin-top: 10px; margin-bottom: 10px;">持续重构</div>
          </div>
        </li>
        <ul>
          <li style="margin-top: 10px; margin-bottom: 10px;">
            <div
              style="
                border-color: rgb(255, 255, 212);
                border-width: 2px;
                border-style: solid;
                background-color: #f0f0f0;
                margin-top: 10px;
                margin-bottom: 10px;
              "
            >
              <div style="margin-top: 10px; margin-bottom: 10px;">
                重构是不改变应用的行为而重新设计代码使得它更好的过程。重构通常是非常谨慎的,
                按照小幅且可控的步骤进行,
                这样我们就不会破坏功能或者引入一些bug了。
              </div>
            </div>
          </li>
          <li style="margin-top: 10px; margin-bottom: 10px;">
            <div
              style="
                border-color: rgb(255, 255, 212);
                border-width: 2px;
                border-style: solid;
                background-color: #f0f0f0;
                margin-top: 10px;
                margin-bottom: 10px;
              "
            >
              <div style="margin-top: 10px; margin-bottom: 10px;">
                代码重构有很多种方式,
                甚至存在重构的模式。这些模式代表了一个重构的自动化方法。
              </div>
            </div>
            <div>这类重构更多是与代码和它的质量有关的。</div>
          </li>
          <li style="margin-top: 10px; margin-bottom: 10px;">
            <div
              style="
                border-color: rgb(255, 255, 212);
                border-width: 2px;
                border-style: solid;
                background-color: #f0f0f0;
                margin-top: 10px;
                margin-bottom: 10px;
              "
            >
              <div style="margin-top: 10px; margin-bottom: 10px;">
                还有另一种类型的重构,
                与领域和它的模型相关。有时会对领域有新的理解,有些事物变得更加清晰,或者发现了两个元素间的关系。
              </div>
            </div>
            <div>
              这带来了一个挑战:如何发现一个深刻的模型(incisive
              model),这个模型能够捕获到领域专家头脑中微妙的概念,并且以此来驱动实际的设计。一个忽略肤浅的表面内容且捕捉到基本内容的模型是一个深层模型(deep
              model)。这会让软件更加与领域专家的思路合拍,也更能满足用户的需要。
            </div>
          </li>
        </ul>
        <li style="margin-top: 10px; margin-bottom: 10px;">
          <div
            style="
              border-color: rgb(214, 232, 255);
              border-width: 2px;
              border-style: solid;
              background-color: #f0f0f0;
              margin-top: 10px;
              margin-bottom: 10px;
            "
          >
            <div style="margin-top: 10px; margin-bottom: 10px;">
              凸现关键概念
            </div>
          </div>
        </li>
        <ul>
          <li style="margin-top: 10px; margin-bottom: 10px;">
            <div
              style="
                border-color: rgb(255, 255, 212);
                border-width: 2px;
                border-style: solid;
                background-color: #f0f0f0;
                margin-top: 10px;
                margin-bottom: 10px;
              "
            >
              <div style="margin-top: 10px; margin-bottom: 10px;">
                有时,会有很少的变更,但却会造成很大的差异。这就是突破。
              </div>
            </div>
            <div>
              突破常包括思维上的变化,如同我们理解模型一样。它也是项目中取得巨大进展的源泉,然而它也有一些缺点。突破可能隐含了大量的重构。
            </div>
          </li>
          <li style="margin-top: 10px; margin-bottom: 10px;">
            <div
              style="
                border-color: rgb(255, 255, 212);
                border-width: 2px;
                border-style: solid;
                background-color: #f0f0f0;
                margin-top: 10px;
                margin-bottom: 10px;
              "
            >
              <div style="margin-top: 10px; margin-bottom: 10px;">
                为达到一次突破, 我们需要将隐含的概念显现出来。
              </div>
            </div>
            <div>第一种发现隐含概念的方式是倾听用到的语言。</div>
            <div>挖掘模型概念的另一种明显的方式是使用领域文献。</div>
          </li>
          <li style="margin-top: 10px; margin-bottom: 10px;">
            <div
              style="
                border-color: rgb(255, 255, 212);
                border-width: 2px;
                border-style: solid;
                background-color: #f0f0f0;
                margin-top: 10px;
                margin-bottom: 10px;
              "
            >
              <div style="margin-top: 10px; margin-bottom: 10px;">
                <div>
                  在将概念显现出来时, 还有其他一些非常有用的概念:
                  <span
                    style="
                      border-bottom-width: 2px;
                      border-bottom-style: solid;
                      border-bottom-color: rgb(0, 0, 255);
                      font-weight: bold;
                      text-decoration: none;
                    "
                    >约束、过程和规约</span
                  >。
                </div>
                <div><br /></div>
                <div>
                  <span
                    style="
                      border-bottom-width: 2px;
                      border-bottom-style: solid;
                      border-bottom-color: rgb(0, 0, 255);
                      font-weight: bold;
                      text-decoration: none;
                    "
                    >约束</span
                  >是一个很简单的表达不变量的方式。无论对象的数据如何变化,不变量都要得到保持。如:
                  person.age &gt;= 0
                </div>
              </div>
            </div>
            <div>
              <span
                style="
                  border-bottom-width: 2px;
                  border-bottom-style: solid;
                  border-bottom-color: rgb(0, 0, 255);
                  font-weight: bold;
                  text-decoration: none;
                "
                >处理过程 </span
              >(process) 通常在代码中被表达为 procedure。
              从我们开始使用面向对象语言后我们就不再用一种过程化的方法,
              所以我们需要为处理过程选择一个对象,
              然后给它添加行为。最好的实现过程的方式是使用<span
                style="
                  border-bottom-width: 2px;
                  border-bottom-style: solid;
                  border-bottom-color: rgb(0, 0, 255);
                  font-weight: bold;
                  text-decoration: none;
                "
                >服务</span
              >。
            </div>
            <div>
              我们在此要介绍的最后一个将概念显现出来的方法是<span
                style="
                  border-bottom-width: 2px;
                  border-bottom-style: solid;
                  border-bottom-color: rgb(0, 0, 255);
                  font-weight: bold;
                  text-decoration: none;
                "
                >规约</span
              >。简单来说, 规约是用来测试一个对象是否满足特定条件的。如:
              post.is_published()
            </div>
          </li>
        </ul>
      </ul>

      <h2>第五章 保持模型的一致性</h2>
      <ul>
        <li style="margin-top: 10px; margin-bottom: 10px;">
          <div
            style="
              border-color: rgb(255, 255, 212);
              border-width: 2px;
              border-style: solid;
              background-color: #f0f0f0;
              margin-top: 10px;
              margin-bottom: 10px;
            "
          >
            <div style="margin-top: 10px; margin-bottom: 10px;">
              本章涉及的是需要多个团队通力配合的大型项目。
            </div>
          </div>
          <div>
            当多个团队开发一个项目时,代码开发是并行完成的,每个团队被分配了模型的一个特定部分。那些部分不是独立的,相互之间存在或多或少的关联。它们都是从一个大的模型出发,然后实现其中的一部分。
          </div>
          <div>
            从一个良好的模型开始, 发展到后来却变成了一个不一致的模型,
            这种情况很容易出现。模型的首要需求是: 模型必须是<span
              style="
                border-bottom-width: 2px;
                border-bottom-style: solid;
                border-bottom-color: rgb(0, 0, 255);
                font-weight: bold;
                text-decoration: none;
              "
              >一致的</span
            >, 保持不变的术语,
            并且没有矛盾。模型内部的一致性被称为“统一”(unification)。
          </div>
          <div>
            不是试图保持一个迟早要四分五裂的大模型,
            我们应该做的是有意识地将大模型分解成多个<span
              style="
                border-bottom-width: 2px;
                border-bottom-style: solid;
                border-bottom-color: rgb(0, 0, 255);
                font-weight: bold;
                text-decoration: none;
              "
              >较小的模型</span
            >。只要遵守它们所绑定的<span
              style="
                border-bottom-width: 2px;
                border-bottom-style: solid;
                border-bottom-color: rgb(0, 0, 255);
                font-weight: bold;
                text-decoration: none;
              "
              >契约</span
            >, 良好整合的小模型能够独立进化。每个模型都应该有一个清晰的<span
              style="
                border-bottom-width: 2px;
                border-bottom-style: solid;
                border-bottom-color: rgb(0, 0, 255);
                font-weight: bold;
                text-decoration: none;
              "
              >边界</span
            >, 模型之间的关系也应该被精确地定义。
          </div>
        </li>
        <li style="margin-top: 10px; margin-bottom: 10px;">
          <div
            style="
              border-color: rgb(214, 232, 255);
              border-width: 2px;
              border-style: solid;
              background-color: #f0f0f0;
              margin-top: 10px;
              margin-bottom: 10px;
            "
          >
            <div style="margin-top: 10px; margin-bottom: 10px;">
              界定的上下文
            </div>
          </div>
        </li>
        <ul>
          <li style="margin-top: 10px; margin-bottom: 10px;">
            <div
              style="
                border-color: rgb(255, 255, 212);
                border-width: 2px;
                border-style: solid;
                background-color: #f0f0f0;
                margin-top: 10px;
                margin-bottom: 10px;
              "
            >
              <div style="margin-top: 10px; margin-bottom: 10px;">
                每一个模型都有一个<span
                  style="
                    border-bottom-width: 2px;
                    border-bottom-style: solid;
                    border-bottom-color: rgb(0, 0, 255);
                    font-weight: bold;
                    text-decoration: none;
                  "
                  >上下文</span
                >。在我们处理一个独立的模型时, 上下文是隐含的,
                我们不需要去定义它。当我们创建一个假定要和其他软件(例如一个遗留应用)交互的应用时,
                很明显新的应用有自己的模型和上下文, 独立于遗留模型及其上下文。
              </div>
            </div>
          </li>
          <li style="margin-top: 10px; margin-bottom: 10px;">
            <div
              style="
                border-color: rgb(255, 255, 212);
                border-width: 2px;
                border-style: solid;
                background-color: #f0f0f0;
                margin-top: 10px;
                margin-bottom: 10px;
              "
            >
              <div style="margin-top: 10px; margin-bottom: 10px;">
                如何将一个大的模型分解成小的模型没有什么固定的准则。
                尽量把那些相关联的以及能形成一个自然概念的元素放在一个模型里。模型应该足够小,
                以便能分配给一个团队去实现。
              </div>
            </div>
            <div>
              主要的思想是<span
                style="
                  border-bottom-width: 2px;
                  border-bottom-style: solid;
                  border-bottom-color: rgb(0, 0, 255);
                  font-weight: bold;
                  text-decoration: none;
                "
                >定义模型的范围</span
              >,定出它的<span
                style="
                  border-bottom-width: 2px;
                  border-bottom-style: solid;
                  border-bottom-color: rgb(0, 0, 255);
                  font-weight: bold;
                  text-decoration: none;
                "
                >上下文的边界</span
              >, 然后尽最大可能保持模型的统一。
            </div>
            <div>
              界定的上下文并不是模块。界定的上下文提供有模型在其中进化的<span
                style="
                  border-bottom-width: 2px;
                  border-bottom-style: solid;
                  border-bottom-color: rgb(0, 0, 255);
                  font-weight: bold;
                  text-decoration: none;
                "
                >逻辑框架</span
              >。模块是被用来组织模型的元素, 因此界定的上下文包含了模块。
            </div>
          </li>
          <li style="margin-top: 10px; margin-bottom: 10px;">
            <div
              style="
                border-color: rgb(255, 255, 212);
                border-width: 2px;
                border-style: solid;
                background-color: #f0f0f0;
                margin-top: 10px;
                margin-bottom: 10px;
              "
            >
              <div style="margin-top: 10px; margin-bottom: 10px;">
                当使用多个模型时,
                每个人在自己的模型之上可以自由地工作。我们都知道自己模型的界限,
                都恪守在这些边界里。我们需要确保模型的纯洁、一致和统一。每个模型应能使重构尽可能容易,而不会影响到其他的模型。设计能够被改进和提炼,以达到最高的纯洁性。
              </div>
            </div>
          </li>
        </ul>
        <li style="margin-top: 10px; margin-bottom: 10px;">
          <div
            style="
              border-color: rgb(214, 232, 255);
              border-width: 2px;
              border-style: solid;
              background-color: #f0f0f0;
              margin-top: 10px;
              margin-bottom: 10px;
            "
          >
            <div style="margin-top: 10px; margin-bottom: 10px;">持续集成</div>
          </div>
        </li>
        <ul>
          <li style="margin-top: 10px; margin-bottom: 10px;">
            <div
              style="
                border-color: rgb(255, 255, 212);
                border-width: 2px;
                border-style: solid;
                background-color: #f0f0f0;
                margin-top: 10px;
                margin-bottom: 10px;
              "
            >
              <div style="margin-top: 10px; margin-bottom: 10px;">
                <div>
                  模型不是一开始就被完全定义。而是先被创建,然后基于对领域新的理解和来自开发过程的反馈持续进化。
                  这意味着新的概念会进入模型,
                  新的元素也会被添加到代码中。所有的这些需求都会被集成进一个统一的模型,
                  进而用代码来实现。
                </div>
                <div><br /></div>
                <div>
                  这也就是为什么持续集成在界定的上下文中如此必要的原因。我们需要这样一个集成的过程,
                  以确保所有新增的元素和模型原有部分能够和谐相处,
                  在代码中也被正确地实现。
                </div>
              </div>
            </div>
            <div>另外一个必要的需求是执行自动化测试。</div>
          </li>
        </ul>
        <li style="margin-top: 10px; margin-bottom: 10px;">
          <div
            style="
              border-color: rgb(214, 232, 255);
              border-width: 2px;
              border-style: solid;
              background-color: #f0f0f0;
              margin-top: 10px;
              margin-bottom: 10px;
            "
          >
            <div style="margin-top: 10px; margin-bottom: 10px;">
              上下文映射
            </div>
          </div>
        </li>
        <ul>
          <li style="margin-top: 10px; margin-bottom: 10px;">
            <div
              style="
                border-color: rgb(255, 255, 212);
                border-width: 2px;
                border-style: solid;
                background-color: #f0f0f0;
                margin-top: 10px;
                margin-bottom: 10px;
              "
            >
              <div style="margin-top: 10px; margin-bottom: 10px;">
                上下文映射 (Context Map)
                是描绘不同的界定上下文和它们之间关系的一份文档。
              </div>
            </div>
            <div>
              如果上下文定义的不清晰,
              很有可能彼此之间互相覆盖。如果上下文之间的关系没有被描绘出来,
              在系统被集成的时候它们就有可能无法工作。
            </div>
            <div>
              <img
                src="/assets/images/20200417/123BBF58-6B32-4CE9-A93D-F98A25BE3B0D.png"
                width="1120"
              />
            </div>
          </li>
          <li style="margin-top: 10px; margin-bottom: 10px;">
            <div
              style="font-size: 18px; margin-top: 10px; margin-bottom: 10px;"
            >
              <a
                href="marginnote3app://note/310394F7-44F3-4FC2-A072-D1EF8A8A093A"
                style="font-size: 18px;"
                >共享内核模式</a
              >
            </div>
            <div
              style="
                border-color: rgb(255, 255, 212);
                border-width: 2px;
                border-style: solid;
                background-color: #f0f0f0;
                margin-top: 10px;
                margin-bottom: 10px;
              "
            >
              <div style="margin-top: 10px; margin-bottom: 10px;">
                工作于紧密关联的应用程序上团队如果缺乏协调,
                有时会进展得很快,但他们的工作成果有可能会很难整合。
              </div>
            </div>
            <div>
              <img
                src="/assets/images/20200417/FFE57CDE-5CF4-4FC0-99F7-00DFBE300FF6.png"
                width="1120"
              />
            </div>
            <div>
              共享内核的目的是减少重复,但是仍保持两个独立的上下文。对于共享内核的开发需要多加小心。两个开发团队都有可能修改内核的代码,还必须对所做的修改做集成。
            </div>
          </li>
          <li style="margin-top: 10px; margin-bottom: 10px;">
            <div
              style="font-size: 18px; margin-top: 10px; margin-bottom: 10px;"
            >
              <a
                href="marginnote3app://note/480BFCFD-6897-4339-87C7-C198195EA4F6"
                style="font-size: 18px;"
                >客户-供应商模式</a
              >
            </div>
            <div
              style="
                border-color: rgb(255, 255, 212);
                border-width: 2px;
                border-style: solid;
                background-color: #f0f0f0;
                margin-top: 10px;
                margin-bottom: 10px;
              "
            >
              <div style="margin-top: 10px; margin-bottom: 10px;">
                有的时候两个子系统之间存在特殊的关系:一个子系统严重依赖另一个。两个子系统所在的上下文是不同的,
                并且一个系统的处理结果被作为另外一个的输入。它们没有共享的内核,
                因为有这样一个内核从概念上说是错误的,
                或者两个子系统要共享代码在技术上不可能实现。
              </div>
            </div>
            <div>
              当我们面对这样一个场景时,我们应该采取行动。报表团队应该扮演客户的角色,
              而在线购物团队应该扮演供应商的角色。两个团队应该定期碰面或者提出碰面邀请
            </div>
          </li>
          <li style="margin-top: 10px; margin-bottom: 10px;">
            <div
              style="font-size: 18px; margin-top: 10px; margin-bottom: 10px;"
            >
              <a
                href="marginnote3app://note/6363A21A-ACDF-4C8B-9E57-6D9CDE9AAA36"
                style="font-size: 18px;"
                >顺从者模式</a
              >
            </div>
            <div
              style="
                border-color: rgb(255, 255, 212);
                border-width: 2px;
                border-style: solid;
                background-color: #f0f0f0;
                margin-top: 10px;
                margin-bottom: 10px;
              "
            >
              <div style="margin-top: 10px; margin-bottom: 10px;">
                (当供应商不想给客户提供帮助时🙃🙄😑)如果客户不得不使用供应商团队的模型,
                而且这个模型做得很好,
                那么就需要顺从这个模型了。客户团队遵从供应商团队的模型,
                完全顺从它。这和共享内核很相似,
                但有一个重要的不同之处。客户团队不能对内核做更改。他们只能将它作为自己模型的一部分,可以在所提供的现有代码上完成构建。
              </div>
            </div>
          </li>
          <li style="margin-top: 10px; margin-bottom: 10px;">
            <div
              style="font-size: 18px; margin-top: 10px; margin-bottom: 10px;"
            >
              <a
                href="marginnote3app://note/29182BB9-21B2-4DCB-9763-07609E428E29"
                style="font-size: 18px;"
                >防崩溃层</a
              >
            </div>
            <div
              style="
                border-color: rgb(255, 255, 212);
                border-width: 2px;
                border-style: solid;
                background-color: #f0f0f0;
                margin-top: 10px;
                margin-bottom: 10px;
              "
            >
              <div style="margin-top: 10px; margin-bottom: 10px;">
                我们会经常遇到以下情况:
                所创建的新应用需要与遗留软件或者一个独立应用交互。
              </div>
            </div>
            <div>
              我们应该在我们的客户端模型和外部模型之间建造一个防崩溃层。
            </div>
            <div>
              <img
                src="/assets/images/20200417/3D5BAD9B-B94C-4F38-95BC-4798DAEA95AA.png"
                width="1120"
              />
            </div>
          </li>
          <li style="margin-top: 10px; margin-bottom: 10px;">
            <div
              style="font-size: 18px; margin-top: 10px; margin-bottom: 10px;"
            >
              <a
                href="marginnote3app://note/B9C2F196-FAB9-4E39-A4F2-C6DB90D12131"
                style="font-size: 18px;"
                >隔离通道</a
              >
            </div>
            <div
              style="
                border-color: rgb(255, 255, 212);
                border-width: 2px;
                border-style: solid;
                background-color: #f0f0f0;
                margin-top: 10px;
                margin-bottom: 10px;
              "
            >
              <div style="margin-top: 10px; margin-bottom: 10px;">
                隔离通道模式适合于以下情况:
                一个企业应用可由几个较小的应用组成,而且从建模的角度来看彼此之间有很少或者没有公共之处。它有一组自己的需求,
                从用户角度看这是一个应用, 但是从建模和设计的观点来看,
                它可以由具有不同实现的独立模型来完成。
              </div>
            </div>
          </li>
          <li style="margin-top: 10px; margin-bottom: 10px;">
            <div
              style="font-size: 18px; margin-top: 10px; margin-bottom: 10px;"
            >
              <a
                href="marginnote3app://note/B0A66232-EF48-4AED-9982-5D74121FF0C3"
                style="font-size: 18px;"
                >开放主机服务</a
              >
            </div>
            <div
              style="
                border-color: rgb(255, 255, 212);
                border-width: 2px;
                border-style: solid;
                background-color: #f0f0f0;
                margin-top: 10px;
                margin-bottom: 10px;
              "
            >
              <div style="margin-top: 10px; margin-bottom: 10px;">
                当一个子系统要和其他很多子系统集成时,
                为每一个子系统定制一个转换器会使整个团队陷入困境。
              </div>
            </div>
            <div>
              这个问题的解决方案是,
              将外部子系统看作服务提供者。如果我们能为这个系统封装一组服务,
              那么所有的其他子系统将会访问这些服务, 我们也就不需要任何转换层。
            </div>
            <div>
              难点在于每一个子系统也许需要以一种特殊的方式和外部子系统交互,
              那么要创建一组一致的服务可能会比较麻烦。
            </div>
          </li>
          <li style="margin-top: 10px; margin-bottom: 10px;">
            <div
              style="font-size: 18px; margin-top: 10px; margin-bottom: 10px;"
            >
              <a
                href="marginnote3app://note/D4BFFF60-1F64-487A-88C3-97D3E4D5CB9F"
                style="font-size: 18px;"
                >提炼</a
              >
            </div>
            <div
              style="
                border-color: rgb(255, 255, 212);
                border-width: 2px;
                border-style: solid;
                background-color: #f0f0f0;
                margin-top: 10px;
                margin-bottom: 10px;
              "
            >
              <div style="margin-top: 10px; margin-bottom: 10px;">
                即使在我们改进和创建很多抽象之后,一个大的领域还是会有一个大的模型。就是在做了很多次重构之后,模型依然会很大。对于这样的情况,
                就需要做一次<span
                  style="
                    border-bottom-width: 2px;
                    border-bottom-style: solid;
                    border-bottom-color: rgb(0, 0, 255);
                    font-weight: bold;
                    text-decoration: none;
                  "
                  >提炼</span
                >了。其思路是定义一个代表领域本质的<span
                  style="
                    border-bottom-width: 2px;
                    border-bottom-style: solid;
                    border-bottom-color: rgb(0, 0, 255);
                    font-weight: bold;
                    text-decoration: none;
                  "
                  >核心域(Core Domain)</span
                >。提炼过程的副产品将是包含了领域中其他部分的<span
                  style="
                    border-bottom-width: 2px;
                    border-bottom-style: solid;
                    border-bottom-color: rgb(0, 0, 255);
                    font-weight: bold;
                    text-decoration: none;
                  "
                  >普通子域(Generic Subdomain)</span
                >。
              </div>
            </div>
            <div>
              对模型做提炼,找到核心域, 提供一种手段将<span
                style="
                  border-bottom-width: 2px;
                  border-bottom-style: solid;
                  border-bottom-color: rgb(0, 0, 255);
                  font-weight: bold;
                  text-decoration: none;
                "
                >核心域</span
              >与<span
                style="
                  border-bottom-width: 2px;
                  border-bottom-style: solid;
                  border-bottom-color: rgb(0, 0, 255);
                  font-weight: bold;
                  text-decoration: none;
                "
                >支持模型和代码</span
              >(mass of supporting model and
              code)容易地区分开来。对最有价值的和专业的概念加以强调。尽量使核心域小一些。
            </div>
            <div>系统的核心域是什么, 取决于我们如何看待系统。</div>
            <div><br /></div>
            <div>对于普通子域, 我们可以:</div>
            <div><br /></div>
            <div>1. 购买现成的解决方案</div>
            <div>2. 外包</div>
            <div>3. 复用已有模型</div>
            <div>4. 自己实现</div>
          </li>
        </ul>
      </ul>

      <h2>第六章 DDD 在今天仍然很重要</h2>
      <ul>
        <li style="margin-top: 10px; margin-bottom: 10px;">
          <div
            style="
              border-color: rgb(255, 255, 212);
              border-width: 2px;
              border-style: solid;
              background-color: #f0f0f0;
              margin-top: 10px;
              margin-bottom: 10px;
            "
          >
            <div style="margin-top: 10px; margin-bottom: 10px;">
              DDD 是我们应该专注于用户所从事领域里的深层问题的指导原则。
            </div>
          </div>
        </li>
        <li style="margin-top: 10px; margin-bottom: 10px;">
          <div
            style="
              border-color: rgb(255, 255, 212);
              border-width: 2px;
              border-style: solid;
              background-color: #f0f0f0;
              margin-top: 10px;
              margin-bottom: 10px;
            "
          >
            <div style="margin-top: 10px; margin-bottom: 10px;">
              同时,敏捷开发过程也有了足够的影响力,大多数项目现在多少都意识到了迭代、与业务伙伴密切协作、应用持续集成和在强沟通环境(high-communication
              environment)下工作的重要性。
            </div>
          </div>
        </li>
      </ul>
    </div>
  </body>
</html>
